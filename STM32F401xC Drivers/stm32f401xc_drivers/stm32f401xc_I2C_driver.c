/*
 * stm32f401xc_I2C_driver.c
 *
 * Created on: Sep 19, 2025
 * Author: Ahmed Ezzat
 */

//------------------------------
// Includes
//------------------------------
#include "stm32f401xc_I2C_driver.h"

//============================================================

/*
 * =======================================================
 * 					  Generic Variables
 * =======================================================
 */
I2C_InitTypedef G_I2C_Config[3] = {0};

//============================================================

/*
 * =======================================================
 * 					  Generic Macros
 * =======================================================
 */
#define I2C1_Index		0
#define I2C2_Index		1
#define I2C3_Index		2

//============================================================

/*
 * =======================================================
 * 					Generic Functions
 * =======================================================
 */
static void MCAL_I2C_SetPins(I2C_TypeDef *I2Cx);
static void I2C_SendAddress(I2C_TypeDef* I2Cx, uint16_t Address , Direction direction );
static Flag_Status I2C_GetFlagStatus(I2C_TypeDef * I2Cx, Status Flag);
static void I2C_GenrateStart(I2C_TypeDef * I2Cx, Function_States State, Start_Type Start);
static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, Function_States NewState);
static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, Function_States NewState);
static void SlaveStates (I2C_TypeDef* I2Cx  ,Slave_State state);

//============================================================

/*
 * ========================================================================
 * 				 				  ISR
 * ========================================================================
 */
void I2C1_ER_IRQHandler (void){

}

void I2C1_EV_IRQHandler (void){
	volatile uint32_t dummy_read = 0 ;
	I2C_TypeDef* I2Cx = I2C1 ;

	// Interrupt handling for both master and slave mode of a device
	uint32_t temp1, temp2, temp3;

	temp1   = I2Cx->CR2 & (I2C_CR2_ITEVTEN) ;
	temp2   = I2Cx->CR2 & (I2C_CR2_ITBUFEN) ;
	temp3   = I2Cx->SR1 & (I2C_SR1_STOPF);


	// Handle For interrupt generated by STOPF event
	// Note : Stop detection flag is applicable only slave mode
	if(temp1 && temp3){
		// STOF flag is set
		// Clear the STOPF ( i.e 1) read SR1 2) Write to CR1 )
		I2Cx->CR1 |= 0x0000;
		SlaveStates(I2Cx,Slave_EV_STOPF);
	}

	temp3  = I2Cx->SR1 & (I2C_SR1_ADDR);

	// Handle For interrupt generated by ADDR event
	// Note : When master mode : Address is sent
	// When Slave mode   : Address matched with own address
	if(temp1 && temp3){
		// Interrupt is generated because of ADDR event
		// Check for device mode
		if(I2Cx->SR2 & ( I2C_SR2_MSL)){
			/* master */
		}
		else{
			// Slave mode
			// Clear the ADDR flag ( read SR1 , read SR2)
			dummy_read = I2Cx->SR1;
			dummy_read = I2Cx->SR2;
			SlaveStates(I2Cx,Slave_EV_ADDR_Sent);
		}
	}

	temp3  = I2Cx->SR1 & ( I2C_SR1_TXE);

	// Handle For interrupt generated by TXE event
	if(temp1 && temp2 && temp3){
		// Check for device mode
		if(I2Cx->SR2 & (I2C_SR2_MSL)){
			/* The device is master */
		}
		else{
			// Slave
			SlaveStates(I2Cx,Slave_EV_TxE);
		}
	}

	temp3  = I2Cx->SR1 & ( I2C_SR1_RXNE);

	// Handle For interrupt generated by 	SB=1, cleared by reading SR1 register followed by writing DR register with Address.
	if(temp1 && temp2 && temp3){
		// Check device mode .
		if(I2Cx->SR2 & ( I2C_SR2_MSL)){
			/* The device is master */
		}
		else{
			// Slave
			SlaveStates(I2Cx,Slave_EV_RxNE);
		}
	}
}

void I2C2_ER_IRQHandler (void){

}

void I2C2_EV_IRQHandler (void){

}

//============================================================

/*
 * =================================================
 * 		   APIs Supported by "SPI DRIVER"
 * =================================================
 */
void MCAL_I2C_Init(I2C_TypeDef * I2Cx, I2C_InitTypedef *I2C_Config){
	uint16_t L_Temp_Reg = 0, Frequency_Range = 0, L_Result = 0;
	uint32_t PCLK1 = 25000000;

	if(I2Cx == I2C1){
		G_I2C_Config[I2C1_Index] = *I2C_Config;
		RCC_I2C1_CLK_EN();
		MCAL_I2C_SetPins(I2C1);
	}
	else if(I2Cx == I2C2){
		G_I2C_Config[I2C2_Index] = *I2C_Config;
		RCC_I2C2_CLK_EN();
		MCAL_I2C_SetPins(I2C2);
	}
	else if(I2Cx == I2C3){
		G_I2C_Config[I2C3_Index] = *I2C_Config;
		RCC_I2C3_CLK_EN();
		MCAL_I2C_SetPins(I2C3);
	}


	if(I2C_Config->I2C_Mode == I2C_Mode_I2C){
		// Peripheral clock frequency
		/* Get the I2Cx CR2 value */
		L_Temp_Reg = I2Cx->CR2;

		/* Clear frequency FREQ[5:0] bits */
		L_Temp_Reg &= ~(I2C_CR2_FREQ);

		/* Set frequency bits depending on PCLK1 value */
		Frequency_Range = (uint16_t)(PCLK1 / 1000000);

		L_Temp_Reg |= Frequency_Range;

		/* Write to I2Cx CR2 */
		I2Cx->CR2 = L_Temp_Reg;

		I2Cx->CR1 &= ~(I2C_CR1_PE);

		L_Temp_Reg = 0;

		if((I2C_Config->I2C_CLK_Speed = I2C_SCLK_SM_50K) || (I2C_Config->I2C_CLK_Speed = I2C_SCLK_SM_100K)){
			// Thigh = Tclk/2 = CRR * Tclk1
		    // CCR   = Thigh / (2 * Tclk1)
			// CCR   = Fclk1 / (2 * I2C_CLKSpeed)
			L_Result = (uint16_t)(PCLK1 / I2C_Config->I2C_CLK_Speed << 1);

			L_Temp_Reg |= L_Result;

			/* Write to I2Cx CRR */
			I2Cx->CCR = L_Temp_Reg;

			//	For instance: in Sm mode, the maximum allowed SCL rise time is 1000 ns.
			//	If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to 0x08 and TPCLK1 = 125 ns
			//	therefore the TRISE[5:0] bits must be programmed with 09h.
			I2Cx->TRISE = Frequency_Range + 1;
		}
		else if((I2C_Config->I2C_CLK_Speed = I2C_SCLK_FM_200K) || (I2C_Config->I2C_CLK_Speed = I2C_SCLK_FM_400K)){
			/* TODO */
		}

		/* Get the I2Cx CR1 value */
		L_Temp_Reg = I2Cx->CR1;

		/* Set Acknowledge, Stretch, General Call Address & I2C Mode */
		L_Temp_Reg |= ((I2C_Config->I2C_ACK_Control) | (I2C_Config->I2C_CLK_StretchMode) | (I2C_Config->I2C_General_Call_Address) | (I2C_Config->I2C_Mode));

		/* Write to I2Cx CR1 */
		I2Cx->CR1 = L_Temp_Reg;

		L_Temp_Reg = 0;

		 if(1 == (I2C_Config->I2C_Slave_Address.I2C_Dual_Address_EN)){
			 L_Temp_Reg = I2C_OAR2_ENDUAL;
			 L_Temp_Reg |= I2C_Config->I2C_Slave_Address.I2C_Secondary_Slave_Address << I2C_OAR2_ADD2_Pos;
			 I2Cx->OAR2 = L_Temp_Reg;
		 }

		 L_Temp_Reg = 0;
		 L_Temp_Reg |= I2C_Config->I2C_Slave_Address.I2C_Primary_Slave_Address << 1;
		 L_Temp_Reg |= I2C_Config->I2C_Slave_Address.I2C_Addressing_Slave_Mode;
		 I2Cx->OAR1 = L_Temp_Reg;
	}
	else if(I2C_Config->I2C_Mode == I2C_Mode_SMBUS){
		/* TODO */
	}

	if((I2C_Config->P_Slave_Event_CallBack != NULL) | (I2C_Config->P_Master_Event_CallBack != NULL)){
		// Enable IRQ
		I2Cx->CR2 |= I2C_CR2_ITBUFEN;
		I2Cx->CR2 |= I2C_CR2_ITEVTEN;
		I2Cx->CR2 |= I2C_CR2_ITERREN;

		if(I2Cx == I2C1){
			NVIC_IRQ_I2C1_EV_EN();
			NVIC_IRQ_I2C1_ER_EN();
		}
		else if(I2Cx == I2C1){
			NVIC_IRQ_I2C2_EV_EN();
			NVIC_IRQ_I2C2_ER_EN();
		}
		else if(I2Cx == I2C3){
			NVIC_IRQ_I2C3_EV_EN();
			NVIC_IRQ_I2C3_ER_EN();
		}

		// Clear Status Register
		I2Cx->SR1 = 0 ;
		I2Cx->SR2 = 0 ;
	}

	// Enable I2C Peripheral
	I2Cx->CR1 |= I2C_CR1_PE;
}

void MCAL_I2C_DeInit(I2C_TypeDef * I2Cx){
	if(I2Cx == I2C1){
		RCC_I2C1_CLK_RST_SET();
		NVIC_IRQ_I2C1_EV_DIS();
		NVIC_IRQ_I2C1_ER_DIS();
	}
	else if(I2Cx == I2C2){
		RCC_I2C2_CLK_RST_SET();
		NVIC_IRQ_I2C2_EV_DIS();
		NVIC_IRQ_I2C2_ER_DIS();
	}
	else if(I2Cx == I2C3){
		RCC_I2C3_CLK_RST_SET();
		NVIC_IRQ_I2C3_EV_DIS();
		NVIC_IRQ_I2C3_ER_DIS();
	}
}

void MCAL_I2C_Master_Tx(I2C_TypeDef * I2Cx, uint16_t DevAdd, uint8_t *Data, uint32_t DataLen, Stop_Condition Stop, Start_Type Start){
	uint32_t L_DataLen = 0;

	// Set the START bit in the I2C_CR1 register to generate a Start condition
	I2C_GenrateStart(I2Cx, StateEnable, Start);

	// Wait for EV5
    // EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address
	while(!(I2C_GetFlagStatus(I2Cx, EV5_FLAG)));

	// Send Address
	I2C_SendAddress(I2Cx, DevAdd , I2C_Direction_Transmitter);

	// Wait EV6
	// EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
	while(!(I2C_GetFlagStatus(I2Cx, EV6_FLAG)));

	// TRA, BUSY, MSL, TXE Flags
	while(!I2C_GetFlagStatus(I2Cx, EVENT_MASTER_BYTE_TRANSMITTING));

	for(L_DataLen = 0; L_DataLen < DataLen ; L_DataLen++){
		/* Write in the DR register the data to be sent */
		I2Cx->DR = Data[L_DataLen];
		// Wait EV8
		// EV8: TxE=1, shift register not empty, d . ata register empty, cleared by writing DR register
		while(!(I2C_GetFlagStatus(I2Cx, EV8_FLAG)));
	}

	// Wait EV8_2
	// EV8_2: TxE=1, BTF = 1, Program Stop request. TxE and BTF are cleared by hardware by the Stop condition
	// While(!I2C_GetFlagStatus(I2Cx, EV8_2));

	if (Stop == With_Stop){
		// Send Stop Condition
		I2C_GenerateSTOP(I2Cx, ENABLE);
	}
}

void MCAL_I2C_Master_Rx(I2C_TypeDef * I2Cx, uint16_t DevAdd, uint8_t *Data, uint32_t DataLen, Stop_Condition Stop, Start_Type Start){
	uint8_t index = 0;

	if(I2Cx == I2C1){
		index = I2C1_Index;
	}
	else if(I2Cx == I2C2){
		index = I2C2_Index;
	}
	else if(I2Cx == I2C3){
		index = I2C3_Index;
	}

	uint32_t L_DataLen = 0;

	I2C_AcknowledgeConfig(I2Cx,StateEnable);

	// Set the START bit in the I2C_CR1 register to generate a Start condition
	I2C_GenrateStart(I2Cx, StateEnable, Start);

	// Wait for EV5
	// EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.
	while(!I2C_GetFlagStatus(I2Cx, EV5_FLAG));

	//3-Send Address
	I2C_SendAddress(I2Cx, DevAdd , I2C_Direction_Recieve);

	// Wait EV6
	// EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
	while(!I2C_GetFlagStatus(I2Cx, EV6_FLAG));

	if(DataLen <= 1){
		I2C_AcknowledgeConfig(I2Cx, StateDisable);
	}
	else{
		I2C_AcknowledgeConfig(I2Cx, StateEnable);
	}

	// Read the data until Len becomes zero
	for (L_DataLen = DataLen ; L_DataLen >= 1 ; L_DataLen--){
		// wait until  RXNE becomes 1
		while(!I2C_GetFlagStatus(I2Cx, EV7_FLAG));

		// Read the data from data register in to buffer
		*Data = I2Cx->DR;

		// Increment the buffer address
		Data++;

		if(L_DataLen == 2){
			I2C_AcknowledgeConfig(I2Cx, StateDisable);
		}
	}

	I2C_AcknowledgeConfig(I2Cx,StateEnable);
	if (Stop == With_Stop){
		// Send Stop Condition
		I2C_GenerateSTOP(I2Cx, StateEnable);
	}

//	// Re-enable ACKing
//	if(G_I2C_Config[index].I2C_ACK_Control == I2C_Ack_EN){
//		I2C_AcknowledgeConfig(I2Cx,StateEnable);
//	}
}

void MCAL_I2C_SlaveSendData(I2C_TypeDef* I2Cx,uint8_t data){
	I2Cx->DR = data;
}

uint8_t MCAL_I2C_SlaveReceiveData(I2C_TypeDef* I2Cx){
	return (uint8_t) I2Cx->DR;
}

//============================================================

/*
 * =================================================
 * 		   		    Generic APIs
 *
 * =================================================
 */
static void MCAL_I2C_SetPins(I2C_TypeDef *I2Cx){
	GPIO_PinConfig_t PinConfig;

	if(I2Cx == I2C1){
		// SDA ===> PB7
		// SCL ===> PB6

		// SDA ===> PB7
		PinConfig.GPIO_PinNumber = GPIO_PIN_7;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF4;
		MCAL_GPIO_Init(GPIOB, &PinConfig);

		// SCL ===> PB6
		PinConfig.GPIO_PinNumber = GPIO_PIN_6;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF4;
		MCAL_GPIO_Init(GPIOB, &PinConfig);
	}
	else if(I2Cx == I2C2){
		// SDA ===> PB3
		// SCL ===> PB10

		// SDA ===> PB3
		PinConfig.GPIO_PinNumber = GPIO_PIN_3;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF9;
		MCAL_GPIO_Init(GPIOB, &PinConfig);

		// SCL ===> PB10
		PinConfig.GPIO_PinNumber = GPIO_PIN_10;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF4;
		MCAL_GPIO_Init(GPIOB, &PinConfig);
	}
	else if(I2Cx ==  I2C3){
		// SDA ===> PB4
		// SCL ===> PA8

		// SDA ===> PB4
		PinConfig.GPIO_PinNumber = GPIO_PIN_4;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF9;
		MCAL_GPIO_Init(GPIOB, &PinConfig);

		// SCL ===> PA8
		PinConfig.GPIO_PinNumber = GPIO_PIN_8;
		PinConfig.GPIO_MODE = GPIO_MODE_AF;
		PinConfig.GPIO_AFx = GPIO_AF4;
		MCAL_GPIO_Init(GPIOA, &PinConfig);
	}
}

static void I2C_SendAddress(I2C_TypeDef* I2Cx, uint16_t Address , Direction direction ){
	Address = (Address << 1 ) ;

	if (direction != I2C_Direction_Transmitter){
		/* Set the address bit0 for read */
		Address |= 1<<0;
	}
	else{
		/* Reset the address bit0 for write */
		Address &= ~(1<<0);
	}

	/* Send the address */
	I2Cx->DR = Address;
}

static void I2C_GenrateStart(I2C_TypeDef * I2Cx, Function_States State, Start_Type Start){
	if(Start != Repeated_Start){
		// Check if The Bus is Idle
		while(I2C_GetFlagStatus(I2Cx, BUSY_FLAG));
	}

	if(State == StateEnable){
		I2Cx->CR1 |= I2C_CR1_START;
	}
	else{
		I2Cx->CR1 &= ~(I2C_CR1_START);
	}

}

static void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, Function_States NewState){
	if (NewState != StateDisable){
		/* Generate a STOP condition */
		I2Cx->CR1 |= I2C_CR1_STOP;
	}
	else{
		/* Disable the STOP condition generation */
		I2Cx->CR1 &= ~(I2C_CR1_STOP);
	}
}

static Flag_Status I2C_GetFlagStatus(I2C_TypeDef * I2Cx, Status Flag){
	volatile uint32_t DummyRead = 0;
	Flag_Status BitStatus = 0;

	uint32_t flag1 = 0, flag2 = 0, LastEvent = 0;

	switch(Flag){
		case BUSY_FLAG:{
			// Bit 1 BUSY: Bus busy
			// 0: No communication on the bus
			// 1: Communication ongoing on the bus
			// – Set by hardware on detection of SDA or SCL low
			// – Cleared by hardware on detection of a Stop condition.
			// It indicates a communication in progress on the bus. This information is still updated when
			// The interface is disabled (PE=0).
			if((I2Cx->SR2) & (I2C_SR2_BUSY))
				BitStatus = SET;
			else
				BitStatus = RST;
			break;
		}

		case EV5_FLAG:{
			// EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.
			// Bit 0 SB: Start bit (Master mode)
			// 0: No Start condition
			// 1: Start condition generated.
			// – Set when a Start condition generated.
			// – Cleared by software by reading the SR1 register followed by writing the DR register, or by
			// Hardware when PE=0
			if((I2Cx->SR1) & (I2C_SR1_SB))
				BitStatus = SET;
			else
				BitStatus = RST;
			break;
		}

		case EV6_FLAG:{
			// EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.
			// Bit 1 ADDR: Address sent (master mode)/matched (slave mode)
			if((I2Cx->SR1) & (I2C_SR1_ADDR))
				BitStatus = SET;
			else
				BitStatus = RST;
			break;
		}

		case EVENT_MASTER_BYTE_TRANSMITTING:{
			flag1 = I2Cx->SR1;
			flag2 = I2Cx->SR2;
			flag2 = flag2 << 16;

			/* Get the last event value from I2C status register by continatination */
			LastEvent = (flag1 | flag2) & ((uint32_t)0x00FFFFFF);

			/* Check whether the last event contains the I2C_EVENT */
			if ((LastEvent & Flag) == Flag){
				/* SUCCESS: last event is equal to I2C_EVENT */
				BitStatus = SET ;
			}
			else{
				/* ERROR: last event is different from I2C_EVENT */
				BitStatus = RST ;
			}
			break;
		}

		// EV8_1: TxE=1, shift register empty, data register empty, write Data1 in DR.
		case EV8_1_FLAG:

		// EV8: TxE=1, shift register not empty, d . ata register empty, cleared by writing DR register
		case EV8_FLAG:{
			// Bit 7 TxE: Data register empty (transmitters)
			// 0: Data register not empty
			// 1: Data register empty
			if(((I2Cx->SR1 ) & (I2C_SR1_TXE) ) )
				BitStatus = SET ;
			else
				BitStatus = RST ;
			break ;
		}

		case EV7_FLAG:{
			// Bit 6 RxNE: Data register not empty (receivers)
			// 0: Data register empty
			// 1: Data register not empty
			// – Set when data register is not empty in receiver mode. RxNE is not set during address phase.
			// – Cleared by software reading or writing the DR register or by hardware when PE=0.
			// RxNE is not set in case of ARLO event.
			if(((I2Cx->SR1 ) & (I2C_SR1_RXNE) ) )
				BitStatus = SET ;
			else
				BitStatus = RST ;
			break ;
		}
	}
	return BitStatus;
}

static void SlaveStates (I2C_TypeDef* I2Cx  ,Slave_State state){

	uint8_t index = 0;

	if(I2Cx == I2C1){
		index = I2C1_Index;
	}
	else if(I2Cx == I2C2){
		index = I2C2_Index;
	}
	else if(I2Cx == I2C3){
		index = I2C3_Index;
	}

	switch(state){

		case Slave_ERR_AF:{
			// Make sure that the slave is really in transmitter mode
			if(I2Cx->SR2 & ( I2C_SR2_TRA))
				//Slave Shouldn't Send anything else
			break ;
		}

		case Slave_EV_STOPF:{
			// Make sure that the slave is really in transmitter mode
			if(I2Cx->SR2 & ( I2C_SR2_TRA))
				// Notify APP that the Stop Condition is sent by the master
				G_I2C_Config [index].P_Slave_Event_CallBack (Slave_EV_STOPF) ;
			break ;
		}

		case Slave_EV_ADDR_Sent:{
			// Notify APP that the Stop Condition is sent by the master
			G_I2C_Config [index].P_Slave_Event_CallBack (Slave_EV_ADDR_Sent) ;
			break ;
		}

		case Slave_EV_TxE:
		{
			// Make sure that the slave is really in transmitter mode
			if(I2Cx->SR2 & ( I2C_SR2_TRA))
				// The APP layer should send the data (MCAL_I2C_SlaveSendData ) in this state
				G_I2C_Config [index].P_Slave_Event_CallBack (Slave_EV_TxE) ;
			break ;
		}
		case Slave_EV_RxNE:{
			//make sure that the slave is really in receiver mode
			if(!(I2Cx->SR2 & ( I2C_SR2_TRA)))
				//the APP layer should read the data (MCAL_I2C_SlaveReceiveData ) in this state
				G_I2C_Config [index].P_Slave_Event_CallBack (Slave_EV_RxNE) ;
			break ;
		}
	}
}

static void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, Function_States NewState){

	if (NewState != StateDisable){
		/* Enable the acknowledgement */
		I2Cx->CR1 |= I2C_CR1_ACK;
	}
	else{
		/* Disable the acknowledgement */
		I2Cx->CR1 &= ~(I2C_CR1_ACK);
	}
}
